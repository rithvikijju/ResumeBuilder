import { createSupabaseServerClient } from "@/lib/supabase/server";
import { ResumeSchema } from "@/lib/resume/schema";
import { getTemplateById } from "@/lib/resume/templates";

export async function GET(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  const supabase = await createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return new Response("Unauthorized", { status: 401 });
  }

  const { data, error } = await supabase
    .from("resumes")
    .select("*")
    .eq("id", id)
    .eq("user_id", user.id)
    .maybeSingle();

  if (error || !data) {
    return new Response("Resume not found", { status: 404 });
  }

  const validation = ResumeSchema.safeParse(data.structured_content);
  if (!validation.success) {
    return new Response("Invalid resume data", { status: 400 });
  }

  const resume = validation.data;
  const templateId = (data as any).template_id || "cs";
  const template = (await getTemplateById(templateId)) || (await getTemplateById("cs"))!;

  // Map font families to LaTeX fonts
  const fontMap: Record<string, string> = {
    "Times New Roman, serif": "\\usepackage{times}",
    "Arial, sans-serif": "\\usepackage{helvet}\n\\renewcommand{\\familydefault}{\\sfdefault}",
    "Calibri, Arial, sans-serif": "\\usepackage{helvet}\n\\renewcommand{\\familydefault}{\\sfdefault}",
  };
  const latexFont = fontMap[template.style.fontFamily] || "";

  // Parse font size
  const fontSize = template.style.fontSize.replace("pt", "") || "11";

  // Build LaTeX document with professional styling matching Jakes-Resume.tex
  let latex = `%-------------------------
% Resume in Latex
% Generated by Resume Builder
%------------------------

\\documentclass[letterpaper,${fontSize}pt]{article}

\\usepackage{latexsym}
\\usepackage[empty]{fullpage}
\\usepackage{titlesec}
\\usepackage{marvosym}
\\usepackage[usenames,dvipsnames]{color}
\\usepackage{verbatim}
\\usepackage{enumitem}
\\usepackage[hidelinks]{hyperref}
\\usepackage{fancyhdr}
\\usepackage[english]{babel}
\\usepackage{tabularx}
${latexFont}

%----------FONT OPTIONS----------
% sans-serif
% \\usepackage[sfdefault]{FiraSans}
% \\usepackage[sfdefault]{roboto}
% \\usepackage[sfdefault]{noto-sans}
% \\usepackage[default]{sourcesanspro}

% serif
% \\usepackage{CormorantGaramond}
% \\usepackage{charter}

\\pagestyle{fancy}
\\fancyhf{} % clear all header and footer fields
\\fancyfoot{}
\\renewcommand{\\headrulewidth}{0pt}
\\renewcommand{\\footrulewidth}{0pt}

% Adjust margins
\\addtolength{\\oddsidemargin}{-0.5in}
\\addtolength{\\evensidemargin}{-0.5in}
\\addtolength{\\textwidth}{1in}
\\addtolength{\\topmargin}{-.5in}
\\addtolength{\\textheight}{1.0in}

\\urlstyle{same}

\\raggedbottom
\\raggedright
\\setlength{\\tabcolsep}{0in}

% Sections formatting
\\titleformat{\\section}{
  \\vspace{-4pt}\\scshape\\raggedright\\large
}{}{0em}{}[\\color{black}\\titlerule \\vspace{-5pt}]

% Ensure that generate pdf is machine readable/ATS parsable
\\pdfgentounicode=1

%-------------------------
% Custom commands
\\newcommand{\\resumeItem}[1]{
  \\item\\small{
    {#1 \\vspace{-2pt}}
  }
}

\\newcommand{\\resumeSubheading}[4]{
  \\vspace{-2pt}\\item
    \\begin{tabular*}{0.97\\textwidth}[t]{l@{\\extracolsep{\\fill}}r}
      \\textbf{#1} & #2 \\\\
      \\textit{\\small#3} & \\textit{\\small #4} \\\\
    \\end{tabular*}\\vspace{-7pt}
}

\\newcommand{\\resumeSubSubheading}[2]{
    \\item
    \\begin{tabular*}{0.97\\textwidth}{l@{\\extracolsep{\\fill}}r}
      \\textit{\\small#1} & \\textit{\\small #2} \\\\
    \\end{tabular*}\\vspace{-7pt}
}

\\newcommand{\\resumeProjectHeading}[2]{
    \\item
    \\begin{tabular*}{0.97\\textwidth}{l@{\\extracolsep{\\fill}}r}
      \\small#1 & #2 \\\\
    \\end{tabular*}\\vspace{-7pt}
}

\\newcommand{\\resumeSubItem}[1]{\\resumeItem{#1}\\vspace{-4pt}}

\\renewcommand\\labelitemii{$\\vcenter{\\hbox{\\tiny$\\bullet$}}$}

\\newcommand{\\resumeSubHeadingListStart}{\\begin{itemize}[leftmargin=0.15in, label={}]}
\\newcommand{\\resumeSubHeadingListEnd}{\\end{itemize}}
\\newcommand{\\resumeItemListStart}{\\begin{itemize}}
\\newcommand{\\resumeItemListEnd}{\\end{itemize}\\vspace{-5pt}}

%-------------------------------------------
%%%%%%  RESUME STARTS HERE  %%%%%%%%%%%%%%%%%%%%%%%%%%%%

\\begin{document}

`;

  // Check if resume is structured format
  const isStructured = "header" in resume || "experience" in resume || "education" in resume;

  if (isStructured) {
    // Handle structured resume format with professional styling
    const structuredResume = resume as Extract<typeof resume, { header?: unknown }>;
    
    // Header info - matching Jakes-Resume.tex style
    if (structuredResume.header) {
      const header = structuredResume.header;
      if (header.name) {
        latex += `%----------HEADING----------\n`;
        latex += `\\begin{center}\n`;
        latex += `    \\textbf{\\Huge \\scshape ${escapeLaTeX(header.name)}} \\\\ \\vspace{1pt}\n`;
        
        const contactParts: string[] = [];
        if (header.phone) {
          contactParts.push(escapeLaTeX(header.phone));
        }
        if (header.email) {
          contactParts.push(`\\href{mailto:${escapeLaTeX(header.email)}}{\\underline{${escapeLaTeX(header.email)}}}`);
        }
        if (header.links && header.links.length > 0) {
          header.links.forEach((link) => {
            contactParts.push(`\\href{${escapeLaTeX(link.url)}}{\\underline{${escapeLaTeX(link.url.replace(/^https?:\/\//, ""))}}}`);
          });
        }
        
        if (contactParts.length > 0) {
          latex += `    \\small ${contactParts.join(" $|$ ")}\n`;
        }
        latex += `\\end{center}\n\n`;
      }
    }

    // Education - using resumeSubheading command
    if (structuredResume.education && structuredResume.education.length > 0) {
      latex += `%-----------EDUCATION-----------\n`;
      latex += `\\section{Education}\n`;
      latex += `  \\resumeSubHeadingListStart\n`;
      structuredResume.education.forEach((edu) => {
        const dateRange = `${escapeLaTeX(edu.start_date || "")} -- ${escapeLaTeX(edu.end_date || "Present")}`;
        latex += `    \\resumeSubheading\n`;
        latex += `      {${escapeLaTeX(edu.institution)}}{${escapeLaTeX(edu.location || "")}}\n`;
        latex += `      {${escapeLaTeX(edu.degree)}}{${dateRange}}\n`;
      });
      latex += `  \\resumeSubHeadingListEnd\n\n`;
    }

    // Experience - using resumeSubheading and resumeItem commands
    if (structuredResume.experience && structuredResume.experience.length > 0) {
      latex += `%-----------EXPERIENCE-----------\n`;
      latex += `\\section{Experience}\n`;
      latex += `  \\resumeSubHeadingListStart\n\n`;
      structuredResume.experience.forEach((exp) => {
        const dateRange = `${escapeLaTeX(exp.start_date || "")} -- ${escapeLaTeX(exp.end_date || "Present")}`;
        latex += `    \\resumeSubheading\n`;
        latex += `      {${escapeLaTeX(exp.title)}}{${dateRange}}\n`;
        latex += `      {${escapeLaTeX(exp.organization)}}{${escapeLaTeX(exp.location || "")}}\n`;
        if (exp.bullets && exp.bullets.length > 0) {
          latex += `      \\resumeItemListStart\n`;
          exp.bullets.forEach((bullet) => {
            latex += `        \\resumeItem{${escapeLaTeX(bullet)}}\n`;
          });
          latex += `      \\resumeItemListEnd\n`;
        }
        latex += `      \n`;
      });
      latex += `  \\resumeSubHeadingListEnd\n\n`;
    }

    // Projects - using resumeProjectHeading command
    if (structuredResume.projects && structuredResume.projects.length > 0) {
      latex += `%-----------PROJECTS-----------\n`;
      latex += `\\section{Projects}\n`;
      latex += `    \\resumeSubHeadingListStart\n`;
      structuredResume.projects.forEach((project) => {
        const dateRange = `${escapeLaTeX(project.start_date || "")} -- ${escapeLaTeX(project.end_date || "Present")}`;
        const techStack = project.tech_stack && project.tech_stack.length > 0 
          ? `\\emph{${escapeLaTeX(project.tech_stack.join(", "))}}`
          : "";
        const projectTitle = techStack 
          ? `\\textbf{${escapeLaTeX(project.name)}} $|$ ${techStack}`
          : `\\textbf{${escapeLaTeX(project.name)}}`;
        
        latex += `      \\resumeProjectHeading\n`;
        latex += `          {${projectTitle}}{${dateRange}}\n`;
        if (project.bullets && project.bullets.length > 0) {
          latex += `          \\resumeItemListStart\n`;
          project.bullets.forEach((bullet) => {
            latex += `            \\resumeItem{${escapeLaTeX(bullet)}}\n`;
          });
          latex += `          \\resumeItemListEnd\n`;
        }
      });
      latex += `    \\resumeSubHeadingListEnd\n\n`;
    }

    // Technical Skills - matching Jakes-Resume.tex style
    if (template.layout.showSkills && structuredResume.technical_skills) {
      latex += `%\n`;
      latex += `%-----------PROGRAMMING SKILLS-----------\n`;
      latex += `\\section{Technical Skills}\n`;
      latex += ` \\begin{itemize}[leftmargin=0.15in, label={}]\n`;
      latex += `    \\small{\\item{\n`;
      
      const skillCategories: string[] = [];
      Object.entries(structuredResume.technical_skills).forEach(([category, skills]) => {
        if (skills && skills.length > 0) {
          skillCategories.push(`     \\textbf{${escapeLaTeX(category)}}{: ${escapeLaTeX(skills.join(", "))}}`);
        }
      });
      
      latex += skillCategories.join(" \\\\\n");
      latex += `\n    }}\n`;
      latex += ` \\end{itemize}\n\n`;
    }
  } else {
    // Handle standard resume format with professional styling
    // Summary
    if (template.layout.showSummary && resume.summary && resume.summary.length > 0) {
      latex += `%-----------SUMMARY-----------\n`;
      latex += `\\section{Professional Summary}\n`;
      latex += `  \\resumeSubHeadingListStart\n`;
      latex += `    \\resumeItemListStart\n`;
      resume.summary.forEach((item) => {
        latex += `      \\resumeItem{${escapeLaTeX(item.sentence)}}\n`;
      });
      latex += `    \\resumeItemListEnd\n`;
      latex += `  \\resumeSubHeadingListEnd\n\n`;
    }

    // Sections in template order
    if ("sections" in resume && resume.sections) {
      const sectionsToShow = template.layout.sectionOrder
        .map((title) => resume.sections.find((s) => s.title === title))
        .filter(Boolean) as typeof resume.sections;

      const remainingSections = resume.sections.filter(
        (s) => !template.layout.sectionOrder.includes(s.title)
      );
      sectionsToShow.push(...remainingSections);

      sectionsToShow.forEach((section) => {
        const sectionTitle = template.category === "finance" 
          ? section.title.toUpperCase() 
          : section.title;
        latex += `%-----------${sectionTitle.toUpperCase().replace(/\s+/g, "_")}-----------\n`;
        latex += `\\section{${escapeLaTeX(sectionTitle)}}\n`;
        latex += `  \\resumeSubHeadingListStart\n`;

        section.items.forEach((item) => {
          if (item.heading) {
            // Try to parse heading for structured format
            const headingMatch = item.heading.match(/^(.+?)\s*\|\s*(.+?)\s*\|\s*(.+)$/);
            if (headingMatch) {
              // Format: "Title | Company | Dates"
              latex += `    \\resumeSubheading\n`;
              latex += `      {${escapeLaTeX(headingMatch[1])}}{${escapeLaTeX(headingMatch[3])}}\n`;
              latex += `      {${escapeLaTeX(headingMatch[2])}}{}\n`;
            } else {
              // Simple heading
              latex += `    \\resumeSubheading\n`;
              latex += `      {${escapeLaTeX(item.heading)}}{}\n`;
              latex += `      {}{}\n`;
            }
            latex += `      \\resumeItemListStart\n`;
            latex += `        \\resumeItem{${escapeLaTeX(item.content)}}\n`;
            if (item.metrics && item.metrics.length > 0) {
              const metricsText = item.metrics
                .map((m) => `${m.value} ${m.label}`)
                .join(", ");
              latex += `        \\resumeItem{${escapeLaTeX(metricsText)}}\n`;
            }
            latex += `      \\resumeItemListEnd\n`;
          } else {
            latex += `    \\resumeItem{${escapeLaTeX(item.content)}}\n`;
          }
        });

        latex += `  \\resumeSubHeadingListEnd\n\n`;
      });
    }

    // Skills
    if (template.layout.showSkills && resume.skills) {
      latex += `%\n`;
      latex += `%-----------PROGRAMMING SKILLS-----------\n`;
      latex += `\\section{Technical Skills}\n`;
      latex += ` \\begin{itemize}[leftmargin=0.15in, label={}]\n`;
      latex += `    \\small{\\item{\n`;
      
      const skillParts: string[] = [];
      if (resume.skills.primary && resume.skills.primary.length > 0) {
        skillParts.push(`     \\textbf{Languages}{: ${escapeLaTeX(resume.skills.primary.join(", "))}}`);
      }
      if (resume.skills.secondary && resume.skills.secondary.length > 0) {
        skillParts.push(`     \\textbf{Frameworks}{: ${escapeLaTeX(resume.skills.secondary.join(", "))}}`);
      }
      if (resume.skills.tools && resume.skills.tools.length > 0) {
        skillParts.push(`     \\textbf{Developer Tools}{: ${escapeLaTeX(resume.skills.tools.join(", "))}}`);
      }
      
      if (skillParts.length > 0) {
        latex += skillParts.join(" \\\\\n");
      } else if (template.layout.skillsFormat === "inline") {
        const allSkills = [
          ...(resume.skills.primary || []),
          ...(resume.skills.secondary || []),
          ...(resume.skills.tools || []),
        ];
        latex += `     ${escapeLaTeX(allSkills.join(", "))}`;
      }
      latex += `\n    }}\n`;
      latex += ` \\end{itemize}\n\n`;
    }
  }

  latex += `\\end{document}
`;

  const filename = `${(data.title || "resume").replace(/[^a-z0-9]/gi, "_")}.tex`;

  return new Response(latex, {
    headers: {
      "Content-Type": "application/x-latex",
      "Content-Disposition": `attachment; filename="${filename}"; filename*=UTF-8''${encodeURIComponent(data.title || "resume")}.tex`,
      "Content-Length": Buffer.byteLength(latex, "utf8").toString(),
    },
  });
}

function escapeLaTeX(text: string): string {
  return text
    .replace(/\\/g, "\\textbackslash{}")
    .replace(/\{/g, "\\{")
    .replace(/\}/g, "\\}")
    .replace(/\$/g, "\\$")
    .replace(/\&/g, "\\&")
    .replace(/#/g, "\\#")
    .replace(/\^/g, "\\textasciicircum{}")
    .replace(/_/g, "\\_")
    .replace(/%/g, "\\%")
    .replace(/~/g, "\\textasciitilde{}");
}

